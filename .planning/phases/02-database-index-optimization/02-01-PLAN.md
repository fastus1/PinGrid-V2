---
phase: 02-database-index-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/shared/migrations/009_add_ownership_indexes.sql
  - backend/src/shared/migrations/010_remove_redundant_indexes.sql
autonomous: true

must_haves:
  truths:
    - "EXPLAIN ANALYZE on ownership verification JOINs shows Index Scan on sections and groups"
    - "Redundant idx_bookmarks_group_position index no longer exists"
    - "All new indexes are valid (not INVALID state from failed concurrent creation)"
  artifacts:
    - path: "backend/src/shared/migrations/009_add_ownership_indexes.sql"
      provides: "Composite indexes for ownership verification JOINs"
      contains: "CREATE INDEX CONCURRENTLY"
    - path: "backend/src/shared/migrations/010_remove_redundant_indexes.sql"
      provides: "Removal of redundant bookmarks index"
      contains: "DROP INDEX CONCURRENTLY"
  key_links:
    - from: "sections table"
      to: "pages table"
      via: "idx_sections_page_id index on sections(page_id)"
      pattern: "idx_sections_page_id"
    - from: "groups table"
      to: "sections table"
      via: "idx_groups_section_id index on groups(section_id)"
      pattern: "idx_groups_section_id"
---

<objective>
Add strategic database indexes for ownership verification JOINs and remove redundant overlapping index.

Purpose: Database queries that traverse the page hierarchy (bookmarks -> groups -> sections -> pages -> users) currently rely on sequential scans for the FK columns used in JOINs. Adding indexes on sections.page_id and groups.section_id enables efficient nested loop or merge joins. Removing the redundant idx_bookmarks_group_position saves storage and write overhead since idx_bookmarks_group_column already covers its use cases via the leftmost prefix rule.

Output: Two SQL migration files that can be applied to production databases without blocking writes (using CONCURRENTLY).
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-database-index-optimization/02-RESEARCH.md
@backend/src/shared/migrations/003_create_sections.sql
@backend/src/shared/migrations/004_create_groups.sql
@backend/src/shared/migrations/005_create_bookmarks.sql
@backend/src/shared/migrations/007_add_column_to_bookmarks.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration 009 to add ownership verification indexes</name>
  <files>backend/src/shared/migrations/009_add_ownership_indexes.sql</files>
  <action>
Create migration file `009_add_ownership_indexes.sql` with:

1. Header comment block following existing migration style (see 003-007 for format)
2. Two CREATE INDEX CONCURRENTLY statements:
   - `idx_sections_page_id` on sections(page_id) - for JOINs from sections to pages
   - `idx_groups_section_id` on groups(section_id) - for JOINs from groups to sections
3. Use `IF NOT EXISTS` clause for idempotency
4. Add COMMENT ON INDEX for each index explaining its purpose

**Important notes:**
- DO NOT wrap in transaction (CONCURRENTLY cannot run inside BEGIN/COMMIT)
- bookmarks.group_id does NOT need a new index because idx_bookmarks_group_column already covers it (group_id is leftmost column)
- sections already has idx_sections_page_position but that composite index is suboptimal for pure FK JOINs where we filter only on page_id

**Migration pattern from research:**
```sql
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_sections_page_id
ON sections(page_id);
```
  </action>
  <verify>
File exists at backend/src/shared/migrations/009_add_ownership_indexes.sql with correct SQL syntax. Verify by:
1. `cat backend/src/shared/migrations/009_add_ownership_indexes.sql` shows both CREATE INDEX CONCURRENTLY statements
2. Both statements use IF NOT EXISTS for idempotency
  </verify>
  <done>Migration file 009 contains two CREATE INDEX CONCURRENTLY IF NOT EXISTS statements for sections(page_id) and groups(section_id)</done>
</task>

<task type="auto">
  <name>Task 2: Create migration 010 to remove redundant bookmarks index</name>
  <files>backend/src/shared/migrations/010_remove_redundant_indexes.sql</files>
  <action>
Create migration file `010_remove_redundant_indexes.sql` with:

1. Header comment block explaining WHY this index is redundant:
   - idx_bookmarks_group_position on (group_id, position) from migration 005
   - idx_bookmarks_group_column on (group_id, column, position) from migration 007
   - The second index covers all queries the first index supported (leftmost prefix rule)
2. One DROP INDEX CONCURRENTLY statement:
   - `DROP INDEX CONCURRENTLY IF EXISTS idx_bookmarks_group_position;`
3. Add a verification comment showing how to confirm the index is removed:
   - SELECT query against pg_indexes for the bookmarks table

**Important notes:**
- Use `IF EXISTS` for idempotency (index may already be removed or never existed in some environments)
- DO NOT wrap in transaction (CONCURRENTLY cannot run inside BEGIN/COMMIT)
- This is a space and write-performance optimization - no query will regress because idx_bookmarks_group_column handles all the same patterns
  </action>
  <verify>
File exists at backend/src/shared/migrations/010_remove_redundant_indexes.sql with correct SQL syntax. Verify by:
1. `cat backend/src/shared/migrations/010_remove_redundant_indexes.sql` shows DROP INDEX CONCURRENTLY IF EXISTS
2. File includes comment explaining the redundancy rationale
  </verify>
  <done>Migration file 010 contains DROP INDEX CONCURRENTLY IF EXISTS for idx_bookmarks_group_position with clear rationale in comments</done>
</task>

</tasks>

<verification>
After both tasks complete, verify the phase success criteria:

1. **DBOPT-01 verification:** Run against database to confirm indexes exist and are valid:
```sql
SELECT indexrelid::regclass as index_name, indisvalid as is_valid
FROM pg_index
WHERE indexrelid IN ('idx_sections_page_id'::regclass, 'idx_groups_section_id'::regclass);
-- Expected: Both indexes exist with is_valid = true
```

2. **DBOPT-02 verification:** Confirm icons_cache uses primary key for domain lookups (no change needed):
```sql
EXPLAIN ANALYZE SELECT favicon_url FROM icons_cache WHERE domain = 'github.com';
-- Expected: Index Scan using icons_cache_pkey
```

3. **DBOPT-03 verification:** Confirm redundant index is removed:
```sql
SELECT indexname FROM pg_indexes WHERE tablename = 'bookmarks' ORDER BY indexname;
-- Expected: Should NOT include idx_bookmarks_group_position
-- Should include: idx_bookmarks_group_column, idx_bookmarks_url, idx_bookmarks_user, idx_bookmarks_visit_count
```

4. **DBOPT-04 verification:** Both migration files use CONCURRENTLY keyword:
```bash
grep -l "CONCURRENTLY" backend/src/shared/migrations/009*.sql backend/src/shared/migrations/010*.sql
-- Expected: Both files listed
```
</verification>

<success_criteria>
- Migration 009 creates two indexes: idx_sections_page_id and idx_groups_section_id
- Migration 010 drops one index: idx_bookmarks_group_position
- All statements use CONCURRENTLY keyword (no write locks during execution)
- All statements use IF NOT EXISTS / IF EXISTS for idempotency
- Files follow existing migration naming and commenting conventions
</success_criteria>

<output>
After completion, create `.planning/phases/02-database-index-optimization/02-01-SUMMARY.md`
</output>
