---
phase: 01-foundation-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/modules/pages/pages.model.js
  - backend/src/modules/sections/sections.model.js
  - backend/src/modules/groups/groups.model.js
  - backend/src/modules/bookmarks/bookmarks.model.js
  - backend/src/modules/import/importService.js
autonomous: true

must_haves:
  truths:
    - "A transaction that fails to acquire a client does not throw a TypeError on release"
    - "A ROLLBACK failure on a dead connection does not mask the original error"
  artifacts:
    - path: "backend/src/modules/pages/pages.model.js"
      provides: "Null-safe transaction in reorderPositions"
      contains: "let client"
    - path: "backend/src/modules/sections/sections.model.js"
      provides: "Null-safe transaction in reorderPositions"
      contains: "let client"
    - path: "backend/src/modules/groups/groups.model.js"
      provides: "Null-safe transaction in reorderPositions"
      contains: "let client"
    - path: "backend/src/modules/bookmarks/bookmarks.model.js"
      provides: "Null-safe transactions in reorderColumn and reorderPositions"
      contains: "let client"
    - path: "backend/src/modules/import/importService.js"
      provides: "Null-safe transaction in importBookmarksToGroup"
      contains: "let client"
  key_links:
    - from: "all 5 transaction files"
      to: "pool.connect()"
      via: "let client declared outside try, assigned inside try"
      pattern: "let client;[\\s\\S]*?try[\\s\\S]*?client = await pool\\.connect"
    - from: "all 5 transaction files"
      to: "client.release()"
      via: "if (client) guard in finally block"
      pattern: "finally[\\s\\S]*?if \\(client\\)[\\s\\S]*?client\\.release"
    - from: "all 5 transaction files"
      to: "ROLLBACK"
      via: "try/catch around ROLLBACK in catch block"
      pattern: "catch[\\s\\S]*?if \\(client\\)[\\s\\S]*?try[\\s\\S]*?ROLLBACK"
---

<objective>
Fix all transaction patterns to be null-safe against pool.connect() failures.

Purpose: Prevent TypeError crashes when pool.connect() fails (e.g., pool exhausted, connection timeout). Prevent ROLLBACK errors from masking the original business logic error.
Output: All 5 files with transaction patterns updated to use the null-safe pattern: `let client` outside try, `if (client)` guards on ROLLBACK and release.
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-hardening/01-RESEARCH.md

@backend/src/modules/pages/pages.model.js
@backend/src/modules/sections/sections.model.js
@backend/src/modules/groups/groups.model.js
@backend/src/modules/bookmarks/bookmarks.model.js
@backend/src/modules/import/importService.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix transaction patterns in pages, sections, and groups models</name>
  <files>backend/src/modules/pages/pages.model.js, backend/src/modules/sections/sections.model.js, backend/src/modules/groups/groups.model.js</files>
  <action>
  Apply the null-safe transaction pattern to 3 model files. Each file has exactly 1 transaction method (`reorderPositions`) with the same bug: `const client = await pool.connect()` is called at the top of the method (outside try), meaning if pool.connect() throws, the catch and finally blocks reference an undefined `client`.

  For each of the 3 files (pages.model.js, sections.model.js, groups.model.js), transform the `reorderPositions` method using this exact pattern:

  **BEFORE (current pattern -- same in all 3 files):**
  ```javascript
  static async reorderPositions(...) {
    const client = await pool.connect();
    try {
      await client.query('BEGIN');
      // ... loop ...
      await client.query('COMMIT');
      return ...;
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }
  ```

  **AFTER (null-safe pattern):**
  ```javascript
  static async reorderPositions(...) {
    let client;
    try {
      client = await pool.connect();
      await client.query('BEGIN');
      // ... loop (unchanged) ...
      await client.query('COMMIT');
      return ...;  // unchanged
    } catch (error) {
      if (client) {
        try {
          await client.query('ROLLBACK');
        } catch (rollbackError) {
          console.error('Rollback failed:', rollbackError.message);
        }
      }
      throw error;
    } finally {
      if (client) {
        client.release();
      }
    }
  }
  ```

  Three changes per method:
  1. Move `pool.connect()` call: Replace `const client = await pool.connect();` BEFORE the try with `let client;` before try and `client = await pool.connect();` as the first line inside try.
  2. Guard ROLLBACK: Replace bare `await client.query('ROLLBACK');` with `if (client) { try { await client.query('ROLLBACK'); } catch (rollbackError) { console.error('Rollback failed:', rollbackError.message); } }`.
  3. Guard release: Replace bare `client.release();` with `if (client) { client.release(); }`.

  Do NOT modify any other methods in these files (create, findById, update, delete, etc. all use `pool.query()` which is safe).
  </action>
  <verify>
  For each of the 3 files:
  - `grep 'let client' backend/src/modules/{pages/pages,sections/sections,groups/groups}.model.js` shows matches in all 3.
  - `grep -c 'const client = await pool.connect' backend/src/modules/{pages/pages,sections/sections,groups/groups}.model.js` returns 0 for all 3.
  - `grep 'if (client)' backend/src/modules/{pages/pages,sections/sections,groups/groups}.model.js` shows matches in all 3.
  - `grep 'Rollback failed' backend/src/modules/{pages/pages,sections/sections,groups/groups}.model.js` shows matches in all 3.
  </verify>
  <done>All 3 model files (pages, sections, groups) use null-safe transaction pattern: let client outside try, if (client) guards on ROLLBACK and release, try/catch around ROLLBACK.</done>
</task>

<task type="auto">
  <name>Task 2: Fix transaction patterns in bookmarks model and import service</name>
  <files>backend/src/modules/bookmarks/bookmarks.model.js, backend/src/modules/import/importService.js</files>
  <action>
  Apply the null-safe transaction pattern to 2 remaining files.

  **bookmarks.model.js** has TWO transaction methods that need fixing:
  1. `reorderColumn` (line 179) -- same pattern as above.
  2. `reorderPositions` (line 220, deprecated) -- same pattern as above.

  Apply the identical transformation as Task 1 to both methods:
  - `let client;` before try
  - `client = await pool.connect();` as first line inside try
  - `if (client) { try { await client.query('ROLLBACK'); } catch (rollbackError) { ... } }` in catch
  - `if (client) { client.release(); }` in finally

  **IMPORTANT for reorderColumn:** After COMMIT, the method does a SELECT query using `client.query(...)` (lines 196-202). This query must remain INSIDE the try block, BEFORE the catch, because it uses the checked-out client. The pattern becomes:
  ```javascript
  let client;
  try {
    client = await pool.connect();
    await client.query('BEGIN');
    // ... loop ...
    await client.query('COMMIT');
    // The select query stays here, inside try, using the checked-out client
    const result = await client.query(...);
    return result.rows;
  } catch (error) {
    if (client) { try { await client.query('ROLLBACK'); } catch (rollbackError) { console.error('Rollback failed:', rollbackError.message); } }
    throw error;
  } finally {
    if (client) { client.release(); }
  }
  ```

  **importService.js** has ONE transaction method (`importBookmarksToGroup`, line 62) with the same bug. Apply the identical null-safe pattern:
  - Current code: `const client = await pool.connect();` at line 63 (outside try, before the `let success` line).
  - Move to: `let client;` before try, `client = await pool.connect();` as first line inside try.
  - Note: the `let success = 0, skipped = 0, failed = 0;` declaration should remain outside the try (it's used in both try and catch paths -- keep it where it is, between `let client;` and `try {`).
  - Apply the same ROLLBACK guard and release guard.

  Do NOT modify any other methods (create, findById, update, etc. use pool.query which is safe).
  </action>
  <verify>
  - `grep -c 'const client = await pool.connect' backend/src/modules/bookmarks/bookmarks.model.js` returns 0.
  - `grep -c 'let client' backend/src/modules/bookmarks/bookmarks.model.js` returns 2 (one per transaction method).
  - `grep -c 'if (client)' backend/src/modules/bookmarks/bookmarks.model.js` returns at least 4 (2 ROLLBACK guards + 2 release guards).
  - `grep -c 'const client = await pool.connect' backend/src/modules/import/importService.js` returns 0.
  - `grep -c 'let client' backend/src/modules/import/importService.js` returns 1.
  - `grep -c 'if (client)' backend/src/modules/import/importService.js` returns at least 2.
  - `grep 'Rollback failed' backend/src/modules/bookmarks/bookmarks.model.js` shows matches.
  - `grep 'Rollback failed' backend/src/modules/import/importService.js` shows matches.
  </verify>
  <done>Both bookmarks.model.js (2 methods) and importService.js (1 method) use null-safe transaction pattern. All 7 transaction methods across the codebase are now null-safe.</done>
</task>

</tasks>

<verification>
After both tasks, verify the complete plan:
1. `grep -rc 'const client = await pool.connect' backend/src/modules/` returns 0 total matches (no unsafe patterns remain).
2. `grep -rc 'let client' backend/src/modules/` returns 7 (1 in pages, 1 in sections, 1 in groups, 2 in bookmarks, 1 in import, plus 1 for the existing success/skipped/failed line context).
3. `grep -rc 'if (client)' backend/src/modules/` returns at least 14 (2 per transaction method x 7 methods = 14, covering ROLLBACK guard + release guard).
4. `grep -rc 'Rollback failed' backend/src/modules/` returns at least 7 (one per transaction method).
</verification>

<success_criteria>
- Zero instances of `const client = await pool.connect()` remain in the codebase
- All 7 transaction methods across 5 files use `let client;` before try
- All 7 catch blocks guard ROLLBACK with `if (client)` and wrap ROLLBACK in try/catch
- All 7 finally blocks guard release with `if (client)`
- No other methods or logic in these files are changed
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-hardening/01-02-SUMMARY.md`
</output>
